"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function conform(t) {
    if (typeof t === 'undefined') {
        return [];
    }
    if (!Array.isArray(t)) {
        return [t];
    }
    return t;
}
exports.conform = conform;
async function concurrentFilter(array, callback) {
    const mapper = async (v) => [v, await callback(v)];
    const mapped = await Promise.all(array.map(mapper));
    return mapped
        .filter(([, f]) => f)
        .map(([v]) => v);
}
exports.concurrentFilter = concurrentFilter;
async function filter(array, callback) {
    const initial = [];
    return reduce(array, async (acc, v, i, arr) => {
        if (await callback(v, i, arr)) {
            acc.push(v);
        }
        return acc;
    }, initial);
}
exports.filter = filter;
async function map(array, callback) {
    const initial = [];
    return reduce(array, async (acc, v, i, arr) => {
        acc.push(await callback(v, i, arr));
        return acc;
    }, initial);
}
exports.map = map;
async function reduce(array, callback, initialValue) {
    const hadInitialValue = typeof initialValue === 'undefined';
    const startingIndex = hadInitialValue ? 1 : 0;
    if (typeof initialValue === 'undefined') {
        if (array.length === 0) {
            throw new TypeError('Reduce of empty array with no initial value');
        }
        initialValue = array[0];
    }
    let value = initialValue;
    for (let i = startingIndex; i < array.length; i++) {
        const v = await callback(value, array[i], i, array);
        value = v;
    }
    return value;
}
exports.reduce = reduce;
